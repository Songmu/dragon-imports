package dragon

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
)

type errWriter struct {
	w   io.Writer
	err error
}

func (e *errWriter) Write(p []byte) (int, error) {
	n := 0
	if e.err == nil {
		n, e.err = e.w.Write(p)
	}
	return n, e.err
}

func out(libChan chan lib, w io.Writer) error {
	libs := map[string]lib{}
	ambiguous := map[string]bool{}
	var keys []string

	for lib := range libChan {
		full := lib.path
		key := lib.pkg + "." + lib.object
		if exist, ok := libs[key]; ok {
			if exist.path != full {
				ambiguous[key] = true
			}
		} else {
			libs[key] = lib
			keys = append(keys, key)
		}
	}
	sort.Strings(keys)

	ew := &errWriter{w, nil}
	fmt.Fprintln(ew, `// AUTO-GENERATED BY dragon-imports

package imports
var stdlib = map[string]string{`)

	for _, key := range keys {
		if ambiguous[key] {
			fmt.Fprintf(ew, "\t// %q is ambiguous\n", key)
		} else {
			fmt.Fprintf(ew, "\t%q: %q,\n", key, libs[key].path)
		}
	}
	fmt.Fprintln(ew, "")
	for _, sym := range [...]string{"Alignof", "ArbitraryType", "Offsetof", "Pointer", "Sizeof"} {
		fmt.Fprintf(ew, "\t%q: %q,\n", "unsafe."+sym, "unsafe")
	}
	fmt.Fprintln(ew, "}")

	return ew.err
}

func outPath() string {
	for _, src := range srcDirs() {
		outPath := filepath.Join(src, "golang.org/x/tools/imports")
		if _, err := os.Stat(outPath); err == nil {
			return outPath
		}
	}
	return ""
}
